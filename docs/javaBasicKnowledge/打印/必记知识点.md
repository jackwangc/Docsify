# 必记知识点

## hashMap 原理

1. hashMap 是一个 entry 数组加链表的组合结构
2. entry 的位置获取
   1. 获取 key 的hashcode
   2. 针对这个 hashcode 进行高16位和低16位的异或运算
   3. 最后与表长的 - 1 进行与运算，获取到 entry 的位置
3. 之所以这样获取位置的原因
   1. 异或运算，降低哈希碰撞概率，使数据分布均匀
   2. `异或获取的值 / lenth - 1`, 只有 -1 才和获取映射的对应位置的 hash 函数`hashcode(key) % length` 取模运算相等，同时比取余运算更加有效率
   3. 不 - 1 的话破坏了位置的均匀分布，进行与运算时有一部分值会取不到，增加碰撞，空间浪费。
   4. 同时扩容时，因为长度为2的倍数，元素的位置不用重新计算，要么在原位置，要么在原位置在移动2的次幂，不用重新计算 hash,效率高

## Synchronized 用过吗，其原理是什么？

1. 是 java 实现互斥同步的一种方式。
2. 通过 monitorenter 和 monitorexit 两个指令在 对象的头设置标记，来获取和释放锁，锁就在对象的对象头里。
3. 一个 monitor 和 一个对象关联，当monitor被某个线程持有就变成了锁定状态。

## Synchronized 优化

1. 开始的 Synchronized 就是一个线程先获取锁然后阻塞所有其他线程，称为重量级锁
2. 改进
   1. 偏向锁：只有一个线程访问代码块，当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID，下次该线程访问时不问建锁
   2. 轻量级锁：有其他线程竞争的话，升级为轻量级锁，以自旋的形式获取锁，不会阻塞
   3. 重量级锁：当自旋超过一定时间，或访问进入线程过多，等待的线程进入阻塞状态

## 单例模式使用synchronized,为什么同时使用volatile？ 

1. 主要用来避免重排序问题导致其他的线程看到了一个已经分配内存和地址但没有初始化的对象，也就是说这个对象还不是处于可用状态，就被其他线程引用了

## JAVA 创建一个对象的过程

1. 检查一个类是否被加载
2. 没有加载先加载类——类加载器
3. 为新生对象分配内存
4. 将分配到的内存空间初始化为零值
5. 执行 `<init>` 对对象进行初始化


