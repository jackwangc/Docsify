# 必记知识点

## hashMap 原理

1. hashMap 是一个 entry 数组加链表的组合结构
2. entry 的位置获取
   1. 获取 key 的hashcode
   2. 针对这个 hashcode 进行高16位和低16位的异或运算
   3. 最后与表长的 - 1 进行与运算，获取到 entry 的位置
3. 之所以这样获取位置的原因
   1. 异或运算，降低哈希碰撞概率，使数据分布均匀
   2. `异或获取的值 / lenth - 1`, 只有 -1 才和获取映射的对应位置的 hash 函数`hashcode(key) % length` 取模运算相等，同时比取余运算更加有效率
   3. 不 - 1 的话破坏了位置的均匀分布，进行与运算时有一部分值会取不到，增加碰撞，空间浪费。
   4. 同时扩容时，因为长度为2的倍数，元素的位置不用重新计算，要么在原位置，要么在原位置在移动2的次幂，不用重新计算 hash,效率高

## Synchronized 用过吗，其原理是什么？

1. 是 java 实现互斥同步的一种方式。
2. 通过 monitorenter 和 monitorexit 两个指令在 对象的头设置标记，来获取和释放锁，锁就在对象的对象头里。
3. 一个 monitor 和 一个对象关联，当monitor被某个线程持有就变成了锁定状态。

## Synchronized 优化

1. 开始的 Synchronized 就是一个线程先获取锁然后阻塞所有其他线程，称为重量级锁
2. 改进
   1. 偏向锁：只有一个线程访问代码块，当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID，下次该线程访问时不问建锁
   2. 轻量级锁：有其他线程竞争的话，升级为轻量级锁，以自旋的形式获取锁，不会阻塞
   3. 重量级锁：当自旋超过一定时间，或访问进入线程过多，等待的线程进入阻塞状态

## 单例模式使用synchronized,为什么同时使用volatile？ 

1. 主要用来避免重排序问题导致其他的线程看到了一个已经分配内存和地址但没有初始化的对象，也就是说这个对象还不是处于可用状态，就被其他线程引用了

## JAVA 创建一个对象的过程

1. 检查一个类是否被加载
2. 没有加载先加载类——类加载器
3. 为新生对象分配内存
4. 将分配到的内存空间初始化为零值
5. 执行 `<init>` 对对象进行初始化

## 进程和线程有什么区别？

1. 根本区别：进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位。

2. 开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

3. 环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

4. 内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

5. 包含关系：只有一个线程的进程可以看做是单进程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

## 浏览器输入 url 的过程

![pic](../../picture/url过程.png)

