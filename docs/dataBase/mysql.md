# Mysql

## 事务

> 满足 acid 特性的一组操作，一致性是最基本的属性，其他属性为了保证一致性
> [原子性，一致性怎么实现的](https://www.zhihu.com/question/30272728)

1. 原子性：事务内部一组操作要么全部成功，要么全部不成功
   1. 原子性的实现依赖于日志，将所有对数据的操作写入日志，当出现错误时，可以进行撤销 
2. 一致性：所有事务对一个数据的读取结果都是相同的
3. 隔离性：一个事务所作的修改在提交之前对其他事物事不可见的
   1. 悲观锁
   2. 乐观锁
4. 持久性：事务提交修改能够永久的保存在数据库当中

## 隔离性

隔离性分为四个级别：

1. 读未提交：(Read Uncommitted)
   1. 在事务开始的时候可以给要准备写操作的这一行数据加一个排它锁，如果是读操作，就给该行数据一个读锁。
   2. 读或写完成时，释放锁，最后 commit 提交。
2. 读已提交（Read Committed） 大多数数据库默认的隔离级别
   1. 是把释放锁的位置调整到事务提交之后
   2. 在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作。
   3. 缺点：在同一个事务中如果两次读取相同的数据时，最后的结果却不一致。这里我们把这种现象称为：不可重复读。
   4. 在事务未提交前，虽然事务内操作的数据是锁定状态，但是另一个事务仍然可以读取，大多数数据库默认的就是这个级别的隔离性。mysql 不是
3. 可重复读（Repeatable-Read) mysql 数据库所默认的级别
   1. 如果事务中存在多次读取同样的数据，MySQL 第一次读的时候仍然会保持选择读最新提交事务的数据
   2. 当第一次之后，之后再读时，mysql 会取第一次读取的数据作为结果。 
4. 序列化（serializable）
   1. 该隔离级别会自动在锁住你要操作的整个表的数据，如果另一个进程事务想要操作表里的任何数据就需要等待获得锁的进程操作完成释放锁。
   2. 可避免脏读、不可重复读、幻读的发生。当然性能会下降很多，会导致很多的进程相互排队竞争锁。 

隔离性用到的锁

1. 一种是悲观锁，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽可能提高性能，发明了各种粒度（数据库级 / 表级 / 行级……）/ 各种性质（共享锁 / 排他锁 / 共享意向锁 / 排他意向锁 / 共享排他意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议 / 死锁检测等一系列的技术。
2. 一种是乐观锁，即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志 UNDO 的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。

MVCC简介

> MVCC是一种多版本并发控制机制。
> 锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.

1. 在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 
2. 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：
3. SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
4. INSERT时，保存当前事务版本号为行的创建版本号
5. DELETE时，保存当前事务版本号为行的删除版本号
6. UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

## 日志

> 使用场景：
> 1. 数据库系统重启崩溃后，数据库处于系统不一致的状态
> 2. 执行一个 crash recovery 过程：
>   1. 读取日志进行redo 操作(重演将所有已经执行成功但尚未写入到磁盘的操作，保持持久性)
>   2. 再对所有崩溃但尚未提交成功的事务进行 undo (撤销所执行的一部分但尚未提交的操作，保持原子性)
> 3. crash recovery 结束，数据库恢复到一致性状态，可以继续被使用

1. undo 日志记录数据修改前的值
2. redo 日志记录数据修改后的值
3. 对于某事务 T，在 log file 的记录中必须开始于事务开始标记（比如 “start T”），结束于事务结束标记（比如 “end T”、”commit T”）。
4. 在系统恢复时，如果在 log file 中某个事务没有事务结束标记，那么需要对这个事务进行 undo 操作，如果有事务结束标记，则 redo。

## 主从复制

> MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行

用途

1. 读写分离
   1. 在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
2. 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换
3. 高可用HA
4. 架构扩展

原理

> 一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点
> [主从复制原理](https://zhuanlan.zhihu.com/p/50597960)

1. 从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；
2. 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
3. Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。


## 范式

1. 第一范式
   1. 每一个属性都不可再分 
2. 第二范式
   1. 每个非主属性依赖于键码
   2. 表中的属性依赖于全部主键
   3. 要有主键，其他字段都依赖于主键
3. 第三范式
   1. 消除数据库中关键字之间的依赖关系
   2. 各种信息出现在一个表中

## 存储引擎

### 区别

存储引擎 | MylSam | innoDB
---|---|---
事务 | 非事务安全 | 事务安全
锁粒度 | 表级 | 行级 
全文索引 | 支持 | 不支持
效率 | 简单，效率高 | 相对低
存储 | 文件 | 数据结构中
索引 | b+ tree </br> 叶子结点存放数据记录地址 | b+ tree </br> 叶子结点存放完整的数据记录
应用场景 | 执行大量 select | 执行大量 insert 和 update
其他 | 不支持外键，不需要全表扫描 | 必须有主键



### innodb

1. 在InnoDB存储引擎中，也有页的概念，默认每个页的大小为16K，也就是每次读取数据时都是读取4*4k的大小！
2. 所以在某一个页内的数据并不是完全有序的
   1. 在某个页内插入新行时，为了不减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间 
3. 数据比较少时，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点
4. 数据多时，这时候就需要进行页分裂，产生一个新的Page
   1. 产生新的Page2，然后将Page1的内容复制到Page2
5. 为什么复制
   1. 如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。并且在innodb中根结点是会预读到内存中的，所以结点的物理地址固定会比较好
6. 增加数据时对b树进行了修改优化
   1. 使用原有模式，这样的话新的页空间利用率只有50%，并且会导致更为频繁的页分裂。
   2. 所以innodb对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。
7. 为什么在innodb中建议设置主键自增的原因
   1. 主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！
   2. 主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！
8. 频繁插入删除，会产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过索引重建来消除碎片提高查询效率

### myisam

1. 主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。
2. 数据的存储不是按主键顺序存放的，按写入的顺序存放
3. innodb引擎数据在物理上是按主键顺序存放，而MyISAM引擎数据在物理上按插入的顺序存放。
4. 非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比innodb的搜索效率会更高。


## 索引

> 一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 
> 数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引

### B+ 索引

1.  B+Tree 索引，又被称为聚集索引，因为无法把数据行存放在两个不同的地方，一个表只能由一个聚集索引

### hash 索引

> InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找.
> 哈希表基本上可以看作是关联数组，一个典型的数据项就像“Jesus => 0x28939″，而0x28939是对内存中表中包含Jesus这一行的引用。在哈系索引的中查询一个像“Jesus”这样的值，并得到对应行的在内存中的引用，明显要比扫描全表获得值为“Jesus”的行的方式快很多

1. 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
2. 无法用于排序与分组；
3. 只支持精确查找，无法用于部分查找和范围查找
   

###  聚集索引和非聚集索引

> SQL索引有两种，聚集索引和非聚集索引
> * MySQL只对<，<=，=，>，>=，BETWEEN，IN。
> * 某些时候的LIKE才会使用索引,以通配符%和_开头作查询时，MySQL 不会使用索引。
> * 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续
> * 字典的拼音查询法就是聚集索引，字典的部首查询就是一个非聚集索引.
> * 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致
> * 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。


### 建立索引的原则

* 定义主键的数据列一定要建立索引
* 定义外键的数据列一定要建立索引
* 对于经常查询的数据列一定要建立索引
* 对于需要在指定范围内快速或频繁查询的数据列
* 经常在 where 字句中的数据列
* 查询很少，重复值比较多的列不要建立索引
* 经常存取的列避免建立索引
* 限制索引的数目

1. 非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。
   1. 通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为回表 
   2. 使用 innodb 引擎需要回表

## 索引优化

1. like的模糊查询以%开头，会导致索引失效。
2. 一个表建的索引尽量不要超过5个。
3. 尽量使用覆盖索引。
4. 尽量不要在重复数据多的列上建索引

## 连接

* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
* inner join(等值连接) 只返回两个表中联结字段相等的行
* full join 返回两个表中的全部数据，匹配补偿的显示 null

## having where

1. ` select cat_id,max(goods_price) from goos group by cat_id` `group by` 和聚合函数一起使用才有意义
2. `select goods_id,good_name,market_price - shop_price as s from goods having s>200 ;` `having`
3. `select goods_id,goods_name from goods where market_price - shop_price > 200;` `where`
4. `select cat_id,goods_name,market_price - shop_price as s from goods where cat_id = 3 having s > 200;`
5. `where` 和 `having` 的区别
   1. where针对表中的列发挥作用，查询数据
   2. having对查询结果中的列发挥作用，筛选数据
6. `order by` 排序
7. `limit` 限制取出哪些数据
8. `distinct` 过滤重复数据

## 锁

> 行级锁(INNODB引擎)、表级锁(MYISAM引擎),InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁,MyISAM和MEMORY采用表级锁(table-level locking)

1. InnoDB行锁是通过给索引上的索引项加锁来实现的。
2. InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
3. 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。
4. MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。

### 使用行锁

```sql
# 1、表中创建索引， select 。。。 where   字段（必须是索引）  不然行锁就无效。
START TRANSACTION; 
# 2、必须要有事务，这样才是 行锁（排他锁）
# 3、在select  语句后面 加 上  FOR UPDATE；
SELECT UserID,Password,Age FROM AccountsDB.Accounts_InFo    WHERE Accounts = 'hello2' FOR UPDATE;
COMMIT;
```

## 参考

1. [MySQL数据库为何要用B+树存储索引](https://mp.weixin.qq.com/s/gaHC7MfFcsiN7N7-gOR9xw)
2. [数据库索引的底层原理](https://mp.weixin.qq.com/s/3cqdS3n5BTJLLPZwj6bzvQ)
3. [数据库acid特性原理](https://www.zhihu.com/question/30272728)