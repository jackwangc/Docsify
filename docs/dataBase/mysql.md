# Mysql

## 事务

> 满足 acid 特性的一组操作

1. 原子性：操作要么全部成功，要么全部不成功
2. 一致性：所有事务对一个数据的读取结果都是相同的
3. 隔离性：一个事务所作的修改在提交之前对其他事物事不可见的
4. 持久性：事务提交修改能够永久的保存早数据库当中

## 范式

1. 第一范式
   1. 每一个属性都不可再分 
2. 第二范式
   1. 每个非主属性依赖于键码
   2. 表中的属性依赖于全部主键
   3. 要有主键，其他字段都依赖于主键
3. 第三范式
   1. 消除数据库中关键字之间的依赖关系
   2. 各种信息出现在一个表中

## 存储引擎

### 区别

存储引擎 | MylSam | innoDB
---|---|---
事务 | 非事务安全 | 事务安全
锁粒度 | 表级 | 行级 
全文索引 | 支持 | 不支持
效率 | 简单，效率高 | 相对低
存储 | 文件 | 数据结构中
索引 | b+ tree </br> 叶子结点存放数据记录地址 | b+ tree </br> 叶子结点存放完整的数据记录
应用场景| 执行大量 select | 执行大量 insert 和 update


### innodb

1. 在InnoDB存储引擎中，也有页的概念，默认每个页的大小为16K，也就是每次读取数据时都是读取4*4k的大小！
2. 所以在某一个页内的数据并不是完全有序的
   1. 在某个页内插入新行时，为了不减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间 
3. 数据比较少时，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点
4. 数据多时，这时候就需要进行页分裂，产生一个新的Page
   1. 产生新的Page2，然后将Page1的内容复制到Page2
5. 为什么复制
   1. 如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。并且在innodb中根结点是会预读到内存中的，所以结点的物理地址固定会比较好
6. 增加数据时对b树进行了修改优化
   1. 使用原有模式，这样的话新的页空间利用率只有50%，并且会导致更为频繁的页分裂。
   2. 所以innodb对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。
7. 为什么在innodb中建议设置主键自增的原因
   1. 主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！
   2. 主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！
8. 频繁插入删除，会产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过索引重建来消除碎片提高查询效率

### myisam

1. 主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。
2. 数据的存储不是按主键顺序存放的，按写入的顺序存放
3. innodb引擎数据在物理上是按主键顺序存放，而MyISAM引擎数据在物理上按插入的顺序存放。
4. 非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比innodb的搜索效率会更高。


## 索引

> 一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 
> 数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引

### B+ 索引

1.  B+Tree 索引，又被称为聚集索引，因为无法把数据行存放在两个不同的地方，一个表只能由一个聚集索引

### hash 索引

> InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找.
> 哈希表基本上可以看作是关联数组，一个典型的数据项就像“Jesus => 0x28939″，而0x28939是对内存中表中包含Jesus这一行的引用。在哈系索引的中查询一个像“Jesus”这样的值，并得到对应行的在内存中的引用，明显要比扫描全表获得值为“Jesus”的行的方式快很多

1. 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
2. 无法用于排序与分组；
3. 只支持精确查找，无法用于部分查找和范围查找
   

###  聚集索引和非聚集索引

> SQL索引有两种，聚集索引和非聚集索引
> * MySQL只对<，<=，=，>，>=，BETWEEN，IN。
> * 某些时候的LIKE才会使用索引,以通配符%和_开头作查询时，MySQL 不会使用索引。
> * 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续
> * 字典的拼音查询法就是聚集索引，字典的部首查询就是一个非聚集索引.
> * 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致
> * 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。


### 建立索引的原则

* 定义主键的数据列一定要建立索引
* 定义外键的数据列一定要建立索引
* 对于经常查询的数据列一定要建立索引
* 对于需要在指定范围内快速或频繁查询的数据列
* 经常在 where 字句中的数据列
* 查询很少，重复值比较多的列不要建立索引
* 经常存取的列避免建立索引
* 限制索引的数目
* 

1. 非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。
   1. 通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为回表 
   2. 使用 innodb 引擎需要回表

## 索引优化

1. like的模糊查询以%开头，会导致索引失效。
2. 一个表建的索引尽量不要超过5个。
3. 尽量使用覆盖索引。
4. 尽量不要在重复数据多的列上建索引

## 连接

* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
* inner join(等值连接) 只返回两个表中联结字段相等的行
* full join 返回两个表中的全部数据，匹配补偿的显示 null
## 参考

1. [MySQL数据库为何要用B+树存储索引](https://mp.weixin.qq.com/s/gaHC7MfFcsiN7N7-gOR9xw)
2. [数据库索引的底层原理](https://mp.weixin.qq.com/s/3cqdS3n5BTJLLPZwj6bzvQ)